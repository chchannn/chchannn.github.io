<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chen Chen</title><link>https://chchannn.github.io/</link><description>Written with ML and Artificial Foolishness</description><atom:link href="https://chchannn.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2021 &lt;a href="mailto:n.tesla@example.com"&gt;Chen Chen&lt;/a&gt; </copyright><lastBuildDate>Sat, 17 Jul 2021 04:40:59 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Maximum Mean Discrepancy for Dummies</title><link>https://chchannn.github.io/posts/maximum-mean-discrepancy-for-dummies/</link><dc:creator>Chen Chen</dc:creator><description>&lt;div&gt;&lt;p&gt;Recently I was working on adding monitoring metrics for my text classification models to detect underlying data drift. Usually it is pretty straightforward to compare two sets of data points to check if they come from the same distribution, when working with structured, tabular inputs. There are many statistical hypothesis testings to measure the distance between two distributions for univariate. When it comes to unstructured text data as inputs, it becomes a more complicated problem. In this scenario I care about the entire vocabulary and how each word's frequency changes. One strategy to measure multivariate drift is using maximum mean discrepancy (MMD), outlined in this paper &lt;a href="https://arxiv.org/abs/1810.11953"&gt;Failing Loudly: An Empirical Study of Methods for Detecting Dataset Shift&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Using a "simple" definition, MMD defines an idea of representing distances between distributions as distances between kernel embedding of distributions. I know this is a very confusing sentence. Here, &lt;em&gt;kernel embedding of distributions&lt;/em&gt;, which has many nick names including kernel mean, feature mean, mean map, or mean embeddings of features, to simplify this mouthful jargon, is described in &lt;a href="https://en.wikipedia.org/wiki/Kernel_embedding_of_distributions"&gt;wikipedia description&lt;/a&gt; as&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;kernel embedding of distributions comprises a class of nonparametric methods in which a probability distribution is represented as an element of a reproducing kernel Hilbert space (RKHS).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When dealing with Hilbert space, I think it is important to keep in mind that, it is simply an extension of the Euclidean space. The Euclidean space, or so called the three-dimensional spaces, or one of those corners of the room that you are in, is an orthogonal space with three perpendicular axes and planes. On the other hand, in the Hilbert space the number of orthogonal axes goes to infinity. The vector operations we like in the Euclidean space such as using inner product, which allows to define distance and angles, are also preserved in the Hilbert space.&lt;/p&gt;
&lt;p&gt;My way to interpret kernel embedding is, like word embedding mapping a word and its semantic meaning to a set of coordinates in an orthogonal space, kernel embedding maps a distribution from domain $\Omega$ (usually non orthogonal) to a set of coordinates in an orthogonal space, so that $k(x,x')=\langle \varphi (x),\varphi (x')\rangle _{\mathcal {H}}$ can be viewed as a measure of similarity between points $x,x'\in \Omega$.
Remembering that in an orthogonal space, distance and angle measurements are more meaningful since axes are not correlated.&lt;/p&gt;
&lt;p&gt;Empirically we can estimate kernel embedding using $$\mu_{X}=\frac{1}{n}\sum_{i=1}^{n}\varphi (x_{i}),$$ this means, if your features $X$ are orthogonal, such as using principle components after PCA, applying a liner kernel transforming features to themselves, the kernel embedding is simply the mean of each feature, or &lt;code&gt;numpy.mean(X, axis=0)&lt;/code&gt;. Kernel embedding are the natural next step in that journey as it provides an orthogonal space to interpret multivariance. It also works seamlessly with dimension reduction methods like PCA.&lt;/p&gt;
&lt;p&gt;Now, circle back to MMD, the goal is to calculate the L2 distance between two kernel embedding, aka two sets of coordinates in the Hilbert space. Recall in vector operations, the L2 distance is defined as &lt;/p&gt;
&lt;div&gt; $$d(X,Y)^{2} = \langle X-Y,X-Y \rangle = \langle X,X \rangle + \langle Y,Y \rangle-2 \langle X,Y \rangle  $$ &lt;/div&gt;
&lt;p&gt;with vector $X, Y \in \mathbb{R}^{n}$ and their inner product as $\langle X,Y \rangle $. 
hence, MMD between $X$ in $P$ distribution and $Y$ in $Q$ distribution defines as
$$ 
MMD^{2}(P,Q)=\langle \mu_{P} , \mu_{P} \rangle -2  \langle \mu_{P} , \mu_{Q} \rangle + \langle \mu_{Q} , \mu_{Q} \rangle$$
Utilizing a property from RKHS quoting Wikipedia,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the expectation of any function $f$ in the RKHS can be computed as an inner product with the kernel embedding.
$$\mathbb {E} [f(X)] = \langle f,\mu_{X}\rangle_{\mathcal {H}},$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;we finally arrive a formula that could allow us to estimate MMD using similarity matrix with kernel transform in domain $\Omega$ as
$$MMD^{2}(P,Q)=E_P[k(X,X)] - 2EP_{Q}[k(X,Y)] + E_Q[k(Y,Y)]$$&lt;/p&gt;
&lt;p&gt;In fact, many existing implementation such as &lt;a href="https://www.kaggle.com/onurtunali/maximum-mean-discrepancy#MAXIMUM-MEAN-DISCREPANCY-(MMD)-IN-MACHINE-LEARNING"&gt;here&lt;/a&gt; or &lt;a href="https://discuss.pytorch.org/t/maximum-mean-discrepancy-mmd-and-radial-basis-function-rbf/1875"&gt;here&lt;/a&gt; use the last formula to guide the computing process.&lt;/p&gt;
&lt;p&gt;Once I understood the similarity matrix could be implemented as &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nv"&gt;def&lt;/span&gt; &lt;span class="nv"&gt;similarity_matrix&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mat&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;:
    # &lt;span class="nv"&gt;get&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;
    # &lt;span class="nv"&gt;here&lt;/span&gt;, &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;.&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt;
    &lt;span class="nv"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;torch&lt;/span&gt;.&lt;span class="nv"&gt;mm&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mat&lt;/span&gt;, &lt;span class="nv"&gt;mat&lt;/span&gt;.&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="ss"&gt;())&lt;/span&gt;
    # &lt;span class="nv"&gt;get&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;diagonal&lt;/span&gt; &lt;span class="nv"&gt;elements&lt;/span&gt;
    &lt;span class="nv"&gt;diag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;r&lt;/span&gt;.&lt;span class="nv"&gt;diag&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt;.&lt;span class="nv"&gt;unsqueeze&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;diag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;diag&lt;/span&gt;.&lt;span class="nv"&gt;expand_as&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;r&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    # &lt;span class="nv"&gt;compute&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;distance&lt;/span&gt; &lt;span class="nv"&gt;matrix&lt;/span&gt;
    &lt;span class="nv"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;diag&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;diag&lt;/span&gt;.&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nv"&gt;r&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;D&lt;/span&gt;.&lt;span class="nv"&gt;sqrt&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;everything else seem to be quickly pieced together.&lt;/p&gt;
&lt;p&gt;This has been a very basic explanation to MMD, it aimed to keep things as simple as possible to describe an basic idea. MMD has extensive application in generative learning. Hopefully this article had built up enough appetite for a more detailed elaboration of the topic such as can be found in the original paper &lt;a href="https://www.jmlr.org/papers/volume13/gretton12a/gretton12a.pdf"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><guid>https://chchannn.github.io/posts/maximum-mean-discrepancy-for-dummies/</guid><pubDate>Sat, 17 Jul 2021 03:24:05 GMT</pubDate></item></channel></rss>